<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–õ–µ—Å–Ω–∞—è –ë–∏—Ç–≤–∞: –ë–æ–π</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap');

        body {
            margin: 0; padding: 0;
            background-color: #1e272e;
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Rubik', sans-serif;
            user-select: none; touch-action: none;
        }

        #game-container {
            position: relative;
            background: #2d5a27;
            width: 100vw; height: 56.25vw;
            max-height: 100vh; max-width: 177.78vh;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }

        .turn-badge {
            margin-top: 2%; padding: 1% 4%;
            background: rgba(0,0,0,0.85); border: 3px solid #fff; border-radius: 12px;
            color: #fff; font-size: 32px; text-transform: uppercase; font-weight: bold;
            text-shadow: 1px 1px 0 #000; transition: 0.3s;
        }
        .turn-badge.green { border-color: #2ecc71; color: #2ecc71; }
        .turn-badge.red { border-color: #e74c3c; color: #e74c3c; }
        .turn-badge.win { border-color: #f1c40f; color: #f1c40f; font-size: 40px;}

        #timer-display {
            font-size: 48px; font-weight: 900; color: white;
            margin-top: 10px; text-shadow: 2px 2px 0 #000;
            transition: color 0.3s;
        }
        #timer-display.low { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.1);} 100% {transform: scale(1);} }

        .ui-panels { position: absolute; bottom: 4%; width: 92%; display: flex; justify-content: space-between; }

        .hero-icon {
            width: 80px; height: 80px; border-radius: 50%; background: #444;
            border: 3px solid #fff; background-size: cover; background-position: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            font-size: 40px; transition: 0.3s; opacity: 0.5; transform: scale(0.9);
        }
        .hero-icon.active { opacity: 1; transform: scale(1.1); border-color: #f1c40f; box-shadow: 0 0 20px #f1c40f; }
        .hero-icon.dead { filter: grayscale(1); }

        .floater {
            position: absolute; font-weight: 900; font-size: 36px;
            animation: floatUp 1s forwards; text-shadow: 2px 2px 0 #000; z-index: 100;
        }
        @keyframes floatUp { to { transform: translateY(-60px); opacity: 0; } }
        
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            pointer-events: auto; padding: 10px 20px;
            background: rgba(0,0,0,0.5); color: #fff; border: 1px solid #fff;
            text-decoration: none; border-radius: 5px; font-size: 14px;
        }
        .back-btn:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="arena"></canvas>
    <div class="ui-layer">
        <a href="menu.html" class="back-btn">‚¨Ö –í –õ–æ–±–±–∏</a>
        <div id="turn-display" class="turn-badge green">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
        <div id="timer-display">30</div>

        <div class="ui-panels">
            <div id="panel-green" style="display:flex; gap:10px;"></div>
            <div id="panel-red" style="display:flex; gap:10px;"></div>
        </div>
    </div>
</div>

<script>
const CFG = {
    width: 1600, height: 900,
    wallPadding: 145, cornerCut: 210,   
    radius: 40, friction: 0.985, wallBounce: 0.7, stopSpeed: 0.15,
    launchSpeed: 45, subSteps: 10,
    reviveAmount: 60,
    maxRevives: 1,
    turnTimeSeconds: 30
};

const HERO_STATS = {
    ranger: { hp: 300, dmg: 50, emoji: "üëÆ‚Äç‚ôÇÔ∏è", name: "–õ–µ—Å–Ω–∏–∫" },
    bear:   { hp: 450, dmg: 35, emoji: "üêª", name: "–ú–µ–¥–≤–µ–¥—å" },
    wolf:   { hp: 250, dmg: 70, emoji: "üê∫", name: "–í–æ–ª–∫" },
    poacher:{ hp: 280, dmg: 60, emoji: "üë∫", name: "–ë—Ä–∞–∫–æ–Ω—å–µ—Ä" }
};

const ASSETS = {
    bg: new Image(),
    ranger: new Image(),
    bear: new Image(),
    wolf: new Image(),
    poacher: new Image()
};

ASSETS.bg.src      = 'img/bg.png';
ASSETS.ranger.src  = 'img/ranger.png';
ASSETS.bear.src    = 'img/bear.png';
ASSETS.wolf.src    = 'img/wolf.png';
ASSETS.poacher.src = 'img/poacher.png';

const V = {
    add: (a, b) => ({x: a.x + b.x, y: a.y + b.y}),
    sub: (a, b) => ({x: a.x - b.x, y: a.y - b.y}),
    mult: (v, n) => ({x: v.x * n, y: v.y * n}),
    mag: (a) => Math.sqrt(a.x*a.x + a.y*a.y),
    norm: (a) => { let m = Math.sqrt(a.x*a.x + a.y*a.y); return m===0 ? {x:0,y:0} : {x:a.x/m, y:a.y/m}; },
    dist: (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2)
};

class Game {
    constructor(p1Key, p2Key) {
        this.container = document.getElementById('game-container');
        this.canvas = document.getElementById('arena');
        this.ctx = this.canvas.getContext('2d');
        
        this.units = [];
        this.walls = [];
        this.state = 'AIMING'; 
        this.drag = { active: false, start: {x:0,y:0}, curr: {x:0,y:0}, unitId: null };
        
        this.turnTime = CFG.turnTimeSeconds;
        this.timerInterval = null;

        // –ü–æ—Ä—è–¥–æ–∫ —Ö–æ–¥–æ–≤: G1 -> R1 -> G2 -> R2
        this.turnOrder = [0, 2, 1, 3]; 
        this.turnStep = 0;
        
        this.activeUnitId = 0; 

        this.p1Key = p1Key;
        this.p2Key = p2Key;

        this.fitScreen();
        window.addEventListener('resize', () => this.fitScreen());

        this.initArena();
        this.initUnits();
        this.bindInput();
        
        this.startTurnLogic(); 
        this.loop();
    }

    // –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –°–ü–ê–í–ù–ê
    initUnits() {
        const sx = CFG.wallPadding + CFG.cornerCut + 30; // –û—Ç—Å—Ç—É–ø X
        const my = CFG.height / 2; // –¶–µ–Ω—Ç—Ä Y
        const spr = 130; // –†–∞–∑–±—Ä–æ—Å Y

        // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–ª–æ—Ç–æ–≤ (–≤–∏–∑—É–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏)
        const spots = [
            { x: sx, y: my - spr },             // 0: –õ–µ–≤—ã–π –í–µ—Ä—Ö (TL)
            { x: CFG.width - sx, y: my - spr }, // 1: –ü—Ä–∞–≤—ã–π –í–µ—Ä—Ö (TR)
            { x: sx, y: my + spr },             // 2: –õ–µ–≤—ã–π –ù–∏–∑ (BL)
            { x: CFG.width - sx, y: my + spr }  // 3: –ü—Ä–∞–≤—ã–π –ù–∏–∑ (BR)
        ];

        /*
           –ö–ê–†–¢–ê –°–•–ï–ú (–í–∞—à –∑–∞–ø—Ä–æ—Å):
           –ò–≥—Ä–æ–∫–∏: p1(G1), p2(G2), p3(R1), p4(R2)
           –°—Ö–µ–º–∞ –º–∞—Å—Å–∏–≤–∞: [–ö—É–¥–∞ –ø–æ–π–¥–µ—Ç p1, –ö—É–¥–∞ –ø–æ–π–¥–µ—Ç p2, –ö—É–¥–∞ –ø–æ–π–¥–µ—Ç p3, –ö—É–¥–∞ –ø–æ–π–¥–µ—Ç p4]
           (–ó–Ω–∞—á–µ–Ω–∏—è - —ç—Ç–æ –∏–Ω–¥–µ–∫—Å—ã spots 0..3)
        */
        const patterns = [
            // 1. p1(TL), p3(TR), p2(BL), p4(BR)
            // p1->0, p2->2, p3->1, p4->3
            [0, 2, 1, 3], 

            // 2. p1(TL), p2(TR), p3(BL), p4(BR)
            // p1->0, p2->1, p3->2, p4->3
            [0, 1, 2, 3],

            // 3. p2(TL), p4(TR), p3(BL), p1(BR)
            // p1->3, p2->0, p3->2, p4->1
            [3, 0, 2, 1],

            // 4. p3(TL), p1(TR), p4(BL), p2(BR)
            // p1->1, p2->3, p3->0, p4->2
            [1, 3, 0, 2]
        ];

        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Å—Ö–µ–º—É
        const randIndex = Math.floor(Math.random() * patterns.length);
        const map = patterns[randIndex];

        this.units = [];
        
        // –°–ø–∞–≤–Ω–∏–º –í –°–¢–†–û–ì–û–ú –ü–û–†–Ø–î–ö–ï (G1, G2, R1, R2), —á—Ç–æ–±—ã ID –≤—Å–µ–≥–¥–∞ –±—ã–ª–∏ 0,1,2,3
        // –ù–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –±–µ—Ä–µ–º –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ö–µ–º—ã
        
        // ID 0: Green P1
        this.spawnUnit('green', this.p1Key, spots[map[0]].x, spots[map[0]].y);
        // ID 1: Green P2
        this.spawnUnit('green', this.p2Key, spots[map[1]].x, spots[map[1]].y);
        // ID 2: Red P1
        this.spawnUnit('red', 'poacher', spots[map[2]].x, spots[map[2]].y);
        // ID 3: Red P2
        this.spawnUnit('red', 'wolf',    spots[map[3]].x, spots[map[3]].y);

        this.updateUI();
    }

    spawnUnit(team, key, x, y) {
        const stats = HERO_STATS[key];
        const safeStats = stats || HERO_STATS['ranger'];
        const safeKey = stats ? key : 'ranger';
        
        this.units.push({
            id: this.units.length,
            team: team,
            name: safeStats.name,
            imgKey: safeKey,
            emoji: safeStats.emoji,
            x: x, y: y, vx: 0, vy: 0,
            hp: safeStats.hp, maxHp: safeStats.hp, dmg: safeStats.dmg,
            isDead: false,
            reviveCount: 0
        });
    }

    getActiveUnit() {
        return this.units[this.activeUnitId];
    }

    startTurnLogic() {
        const scheduledUnitId = this.turnOrder[this.turnStep % 4];
        let scheduledUnit = this.units[scheduledUnitId];

        if (scheduledUnit.isDead) {
            const ally = this.units.find(u => u.team === scheduledUnit.team && u.id !== scheduledUnitId && !u.isDead);
            if (ally) {
                this.activeUnitId = ally.id;
                this.floatText(ally.x, ally.y, "–ó–ê –î–†–£–ì–ê!", "#f1c40f");
            } else {
                this.nextTurnIndex();
                return;
            }
        } else {
            this.activeUnitId = scheduledUnitId;
        }

        const activeUnit = this.getActiveUnit();
        this.updateBanner(`–•–û–î: ${activeUnit.name}`, activeUnit.team);
        this.updateUI();
        
        this.state = 'AIMING';
        this.startTimer();
    }

    nextTurnIndex() {
        const gLive = this.units.some(u => u.team==='green' && !u.isDead);
        const rLive = this.units.some(u => u.team==='red' && !u.isDead);
        
        if(!gLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –ë—Ä–∞–∫–æ–Ω—å–µ—Ä–æ–≤', 'win'); }
        if(!rLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –õ–µ—Å—Ö–æ–∑–∞', 'win'); }

        this.turnStep++;
        this.startTurnLogic();
    }

    startTimer() {
        this.stopTimer();
        this.turnTime = CFG.turnTimeSeconds;
        this.updateTimerUI();

        this.timerInterval = setInterval(() => {
            this.turnTime--;
            this.updateTimerUI();

            if (this.turnTime <= 0) {
                this.stopTimer();
                this.forceRandomTurn();
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
        document.getElementById('timer-display').className = '';
    }

    updateTimerUI() {
        const el = document.getElementById('timer-display');
        el.innerText = this.turnTime;
        if (this.turnTime <= 10) el.classList.add('low');
        else el.classList.remove('low');
    }

    forceRandomTurn() {
        const unit = this.getActiveUnit();
        if (unit.isDead) {
            this.nextTurnIndex();
            return;
        }

        const angle = Math.random() * Math.PI * 2;
        const power = 100;
        const vec = {
            x: Math.cos(angle) * power,
            y: Math.sin(angle) * power
        };

        this.floatText(unit.x, unit.y, "AUTO!", '#f39c12');
        this.shoot(unit.id, vec);
    }

    fitScreen() {
        const aspect = 16 / 9;
        let w = window.innerWidth;
        let h = window.innerHeight;
        if (w / h > aspect) w = h * aspect;
        else h = w / aspect;
        this.container.style.width = w + 'px';
        this.container.style.height = h + 'px';
        this.canvas.width = CFG.width;
        this.canvas.height = CFG.height;
    }

    getMousePos(evt) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    initArena() {
        const pad = CFG.wallPadding;
        const c = CFG.cornerCut;
        const w = CFG.width;
        const h = CFG.height;
        const points = [
            {x: pad + c, y: pad}, {x: w - pad - c, y: pad}, 
            {x: w - pad, y: pad + c}, {x: w - pad, y: h - pad - c}, 
            {x: w - pad - c, y: h - pad}, {x: pad + c, y: h - pad}, 
            {x: pad, y: h - pad - c}, {x: pad, y: pad + c}
        ];
        this.walls = [];
        for(let i=0; i<points.length; i++) {
            this.walls.push({ p1: points[i], p2: points[(i+1)%points.length] });
        }
    }

    bindInput() {
        const onDown = (e) => {
            if (this.state !== 'AIMING') return;
            const pos = this.getMousePos(e);
            const activeUnit = this.getActiveUnit();
            const clickedUnit = this.units.find(u => !u.isDead && V.dist(pos, u) < CFG.radius * 2);
            
            if (clickedUnit && clickedUnit.id === activeUnit.id) {
                this.drag.active = true;
                this.drag.unitId = clickedUnit.id;
                this.drag.start = pos;
                this.drag.curr = pos;
            }
        };
        const onMove = (e) => {
            if (this.drag.active) this.drag.curr = this.getMousePos(e);
        };
        const onUp = (e) => {
            if (this.drag.active) {
                if (e.button === 2) { 
                    this.drag.active = false;
                    return;
                }
                this.drag.active = false;
                const vec = V.sub(this.drag.start, this.drag.curr);
                if (V.mag(vec) > 10) this.shoot(this.drag.unitId, vec);
            }
        };

        this.canvas.addEventListener('contextmenu', e => { e.preventDefault(); this.drag.active = false; });
        this.canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        this.canvas.addEventListener('touchstart', onDown, {passive: false});
        this.canvas.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onUp);
    }

    shoot(id, rawVec) {
        this.stopTimer();
        const u = this.units[id];
        const dir = V.norm(rawVec);
        u.vx = dir.x * CFG.launchSpeed;
        u.vy = dir.y * CFG.launchSpeed;
        this.state = 'MOVING';
        this.updateBanner('–î–≤–∏–∂–µ–Ω–∏–µ...', 'grey');
    }

    update() {
        if (this.state === 'MOVING') {
            let active = false;
            const steps = CFG.subSteps;
            
            for(let s=0; s<steps; s++) {
                this.units.forEach(u => {
                    u.x += u.vx / steps; 
                    u.y += u.vy / steps;
                    
                    for (let w of this.walls) {
                        this.solveWall(u, w);
                    }
                });

                for (let i=0; i<this.units.length; i++) {
                    for (let j=i+1; j<this.units.length; j++) {
                        this.solveCollision(this.units[i], this.units[j]);
                    }
                }
            }

            this.units.forEach(u => {
                u.vx *= CFG.friction;
                u.vy *= CFG.friction;
                if (V.mag({x:u.vx, y:u.vy}) > CFG.stopSpeed) active = true;
                else { u.vx = 0; u.vy = 0; }
            });

            if (!active) this.nextTurnIndex();
        }
    }

    solveWall(u, w) {
        const dist = this.getDistToLine(u, w.p1, w.p2);
        if (dist < CFG.radius) {
            const dx = w.p2.x - w.p1.x; const dy = w.p2.y - w.p1.y;
            const lenW = Math.sqrt(dx*dx + dy*dy);
            const nx = dx/lenW; const ny = dy/lenW;
            const t = ((u.x - w.p1.x)*nx + (u.y - w.p1.y)*ny);
            let cx = w.p1.x + t*nx; let cy = w.p1.y + t*ny; 
            if(t<0){cx=w.p1.x;cy=w.p1.y;} else if(t>lenW){cx=w.p2.x;cy=w.p2.y;}

            const nxColl = (u.x - cx) / dist; 
            const nyColl = (u.y - cy) / dist;
            u.x += nxColl * (CFG.radius - dist);
            u.y += nyColl * (CFG.radius - dist);
            
            const dp = u.vx * nxColl + u.vy * nyColl;
            u.vx = (u.vx - 2 * dp * nxColl) * CFG.wallBounce;
            u.vy = (u.vy - 2 * dp * nyColl) * CFG.wallBounce;

            if (u.isDead && Math.abs(dp) > 2) {
                this.heal(u, CFG.reviveAmount);
            }
        }
    }

    solveCollision(u1, u2) {
        const dx = u2.x - u1.x; const dy = u2.y - u1.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < CFG.radius * 2) {
            const nx = dx / dist; const ny = dy / dist;
            const overlap = (CFG.radius * 2 - dist) / 2;
            u1.x -= nx * overlap; u1.y -= ny * overlap;
            u2.x += nx * overlap; u2.y += ny * overlap;
            const rvx = u1.vx - u2.vx; const rvy = u1.vy - u2.vy;
            const velNormal = rvx * nx + rvy * ny;
            if (velNormal < 0) return;
            
            const impulse = velNormal; 
            u1.vx -= impulse * nx; u1.vy -= impulse * ny;
            u2.vx += impulse * nx; u2.vy += impulse * ny;
            
            const impact = Math.abs(impulse);
            if (impact > 0.1) {
                if (u1.team === u2.team) {
                    if (u1.isDead) this.heal(u1, CFG.reviveAmount);
                    if (u2.isDead) this.heal(u2, CFG.reviveAmount);
                } else {
                    if (this.state === 'MOVING') {
                        if (!u1.isDead && !u2.isDead) {
                            const activeTeam = this.units[this.activeUnitId].team;
                            if (activeTeam === u1.team) this.dmg(u2, u1.dmg);
                            if (activeTeam === u2.team) this.dmg(u1, u2.dmg);
                        }
                    }
                }
            }
        }
    }

    heal(u, amt) {
        if (!u.isDead) return;
        if (u.reviveCount >= CFG.maxRevives) return;

        if(!u.lastHeal || Date.now() - u.lastHeal > 200) {
            u.hp += amt;
            this.floatText(u.x, u.y, `+${amt}`, '#3498db');
            u.lastHeal = Date.now();
        } else {
            u.hp += amt;
        }

        if (u.hp >= u.maxHp) {
            u.hp = u.maxHp;
            u.isDead = false;
            u.vx *= 0.5; u.vy *= 0.5;
            u.reviveCount++;
            this.floatText(u.x, u.y, "–û–ñ–ò–õ!", '#f1c40f');
            this.updateUI();
        }
    }

    dmg(u, amt) {
        if(u.isDead) return;
        u.hp -= amt;
        if(!u.lastDmg || Date.now() - u.lastDmg > 500) {
            this.floatText(u.x, u.y, `-${Math.round(amt)}`, '#e74c3c');
            u.lastDmg = Date.now();
        }
        if (u.hp <= 0) { 
            u.hp = 0; 
            u.isDead = true; 
            u.vx*=0.5; u.vy*=0.5; 
            this.updateUI();
        }
    }

    drawBackground() {
        const ctx = this.ctx;
        ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0, CFG.width, CFG.height);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 10;
        ctx.beginPath(); ctx.moveTo(CFG.width/2, 0); ctx.lineTo(CFG.width/2, CFG.height); ctx.stroke();
        ctx.beginPath(); ctx.arc(CFG.width/2, CFG.height/2, 150, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#1e3c1b'; ctx.lineWidth = 5;
        ctx.beginPath();
        this.walls.forEach(w => { ctx.moveTo(w.p1.x, w.p1.y); ctx.lineTo(w.p2.x, w.p2.y); });
        ctx.stroke();
    }

    drawUnit(u) {
        const ctx = this.ctx;
        const r = CFG.radius;
        ctx.save(); ctx.translate(u.x, u.y);
        
        if(u.isDead) ctx.filter = 'grayscale(1) brightness(0.5)';

        ctx.beginPath(); ctx.arc(5,5,r,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fill();

        if (this.state==='AIMING' && u.id === this.activeUnitId && !u.isDead) {
            ctx.beginPath(); ctx.arc(0,0,r+5,0,Math.PI*2);
            ctx.strokeStyle='#f1c40f'; ctx.lineWidth=5; ctx.stroke();
        }

        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.save(); ctx.clip();
        
        const img = ASSETS[u.imgKey];
        if (img && img.complete && img.naturalWidth !== 0) {
            const sSize = Math.min(img.width, img.height);
            const sx = (img.width - sSize) / 2;
            const sy = (img.height - sSize) / 2;
            ctx.drawImage(img, sx, sy, sSize, sSize, -r, -r, r*2, r*2);
        } else {
            ctx.fillStyle = u.team==='green'?'#2ecc71':'#e74c3c'; ctx.fill();
            ctx.fillStyle='#fff'; ctx.font='45px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(u.emoji, 0, 5); 
        }
        ctx.restore();

        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.lineWidth=4; 
        ctx.strokeStyle = u.team==='green'?'#2ecc71':'#e74c3c'; ctx.stroke();

        const pct = u.hp/u.maxHp;
        ctx.fillStyle='#333'; ctx.fillRect(-30, r+10, 60, 10);
        
        if (u.isDead) {
            if (u.reviveCount >= CFG.maxRevives) {
                ctx.fillStyle = '#555'; 
                ctx.fillRect(-28, r+12, 56, 6); 
                ctx.font='20px Arial'; ctx.textAlign='center'; ctx.fillStyle='#ff0000'; 
                ctx.fillText('‚ùå', 0, -r/2);
            } else {
                ctx.fillStyle = '#3498db'; 
                ctx.fillRect(-28, r+12, 56*pct, 6);
                ctx.font='20px Arial'; ctx.textAlign='center'; ctx.fillStyle='#fff'; 
                ctx.fillText('üíÄ', 0, -r/2);
            }
        } else {
            ctx.fillStyle = u.team==='green'?'#2ecc71':'#e74c3c';
            ctx.fillRect(-28, r+12, 56*pct, 6);
        }

        ctx.restore();
    }
    
    getDistToLine(u, p1, p2) {
        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
        const lenW = Math.sqrt(dx*dx + dy*dy);
        const nx = dx/lenW; const ny = dy/lenW;
        const t = ((u.x - p1.x)*nx + (u.y - p1.y)*ny);
        let cx, cy;
        if(t < 0) { cx = p1.x; cy = p1.y; }
        else if(t > lenW) { cx = p2.x; cy = p2.y; }
        else { cx = p1.x + t*nx; cy = p1.y + t*ny; }
        return Math.sqrt((u.x-cx)**2 + (u.y-cy)**2);
    }

    predictHit(u, vec) {
        const maxDist = 2500; 
        const dir = V.norm(vec);
        let cx = u.x; let cy = u.y;
        const step = 10;
        
        for(let d=0; d<maxDist; d+=step) {
            cx += dir.x * step; cy += dir.y * step;
            for(let w of this.walls) {
                const dist = this.getDistToLine({x:cx,y:cy}, w.p1, w.p2);
                if(dist < CFG.radius) {
                    const dx = w.p2.x - w.p1.x; const dy = w.p2.y - w.p1.y;
                    const lenW = Math.sqrt(dx*dx + dy*dy);
                    const nx = dx/lenW; const ny = dy/lenW; 
                    const wnx = -ny; const wny = nx;
                    const dot = dir.x*wnx + dir.y*wny;
                    return { type: 'wall', x: cx, y: cy, rx: dir.x - 2*dot*wnx, ry: dir.y - 2*dot*wny };
                }
            }
            for(let other of this.units) {
                if(other.id === u.id || other.isDead) continue;
                const dist = Math.sqrt((cx - other.x)**2 + (cy - other.y)**2);
                if(dist < CFG.radius * 2) {
                    let nx = cx - other.x; let ny = cy - other.y;
                    const ln = Math.sqrt(nx*nx + ny*ny);
                    nx/=ln; ny/=ln;
                    const dot = dir.x*nx + dir.y*ny;
                    return { type: 'unit', x: cx, y: cy, rx: dir.x - 2*dot*nx, ry: dir.y - 2*dot*ny, enemy: other.team !== u.team ? other : null };
                }
            }
        }
        return { type: 'none', x: cx, y: cy };
    }

    drawAim() {
        const u = this.units[this.drag.unitId];
        const vec = V.sub(this.drag.start, this.drag.curr);
        const hit = this.predictHit(u, vec);
        const dir = V.norm(vec);
        const startX = u.x + dir.x * CFG.radius;
        const startY = u.y + dir.y * CFG.radius;

        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(hit.x, hit.y);
        this.ctx.lineWidth = 6;
        this.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        this.ctx.setLineDash([15,10]);
        this.ctx.stroke();
        this.ctx.setLineDash([]);

        if(hit.type !== 'none' && hit.rx) {
            this.ctx.beginPath();
            this.ctx.arc(hit.x, hit.y, 6, 0, Math.PI*2);
            this.ctx.fillStyle = '#fff';
            this.ctx.fill();
            const bounceLen = 50;
            this.ctx.beginPath();
            this.ctx.moveTo(hit.x, hit.y);
            this.ctx.lineTo(hit.x + hit.rx * bounceLen, hit.y + hit.ry * bounceLen);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            this.ctx.stroke();
        }

        if(hit.enemy) {
            const en = hit.enemy;
            this.ctx.save();
            this.ctx.translate(en.x, en.y - 65);
            this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
            this.ctx.fillRect(-40, -30, 80, 40);
            this.ctx.strokeStyle = 'white';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(-40, -30, 80, 40);
            this.ctx.fillStyle = '#ff5555';
            this.ctx.font = 'bold 24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`-${u.dmg}`, 0, -2);
            this.ctx.restore();
        }
    }

    updateBanner(txt, type) {
        const el = document.getElementById('turn-display');
        el.innerText = txt;
        el.className = `turn-badge ${type}`;
    }

    updateUI() {
        const render = (id, list) => {
            const div = document.getElementById(id);
            div.innerHTML='';
            list.forEach(u => {
                const d = document.createElement('div');
                d.className = `hero-icon ${u.isDead?'dead':''}`;
                
                if (u.id === this.activeUnitId) d.classList.add('active');

                const img = ASSETS[u.imgKey];
                if(img && img.complete && img.naturalWidth !== 0) {
                     d.style.backgroundImage = `url(${img.src})`;
                     d.innerText = '';
                } else {
                     d.innerText = u.emoji;
                     d.style.color = '#fff';
                     d.style.display = 'flex';
                }
                div.appendChild(d);
            });
        };
        render('panel-green', this.units.filter(u=>u.team==='green'));
        render('panel-red', this.units.filter(u=>u.team==='red'));
    }

    floatText(x, y, txt, col) {
        const wrapper = document.getElementById('game-container');
        const pctX = (x / CFG.width) * 100;
        const pctY = (y / CFG.height) * 100;
        const el = document.createElement('div');
        el.className='floater'; 
        el.style.left = pctX + '%'; el.style.top = pctY + '%';
        el.style.color = col; el.innerText = txt;
        wrapper.appendChild(el);
        setTimeout(()=>el.remove(), 1200);
    }

    loop() {
        this.update();
        this.ctx.clearRect(0,0, CFG.width, CFG.height);
        
        if (ASSETS.bg.complete && ASSETS.bg.naturalWidth !== 0) {
            this.ctx.drawImage(ASSETS.bg, 0, 0, CFG.width, CFG.height);
        } else {
            this.drawBackground();
        }

        if (this.state === 'AIMING' && this.drag.active) this.drawAim();
        this.units.forEach(u => this.drawUnit(u));
        requestAnimationFrame(() => this.loop());
    }
}

// –ó–∞–ø—É—Å–∫ —Å —á—Ç–µ–Ω–∏–µ–º HASH
window.onload = () => {
    const hash = window.location.hash.substring(1); 
    const params = new URLSearchParams(hash);
    const p1 = params.get('p1');
    const p2 = params.get('p2');

    if(!p1 || !p2) {
        window.location.href = 'index.html';
        return;
    }

    new Game(p1, p2);
};
</script>
</body>
</html>