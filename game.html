<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–õ–µ—Å–Ω–∞—è –ë–∏—Ç–≤–∞: –ë–æ–π</title>
    <!-- –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï SOCKET.IO -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap');

        body {
            margin: 0; padding: 0;
            background-color: #1e272e;
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Rubik', sans-serif;
            user-select: none; touch-action: none;
        }

        #game-container {
            position: relative;
            background: #2d5a27;
            width: 100vw; height: 56.25vw;
            max-height: 100vh; max-width: 177.78vh;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }

        .turn-badge {
            margin-top: 2%; padding: 1% 4%;
            background: rgba(0,0,0,0.85); border: 3px solid #fff; border-radius: 12px;
            color: #fff; font-size: 32px; text-transform: uppercase; font-weight: bold;
            text-shadow: 1px 1px 0 #000; transition: 0.3s;
        }
        .turn-badge.green { border-color: #2ecc71; color: #2ecc71; }
        .turn-badge.red { border-color: #e74c3c; color: #e74c3c; }
        .turn-badge.win { border-color: #f1c40f; color: #f1c40f; font-size: 40px;}

        #timer-display {
            font-size: 48px; font-weight: 900; color: white;
            margin-top: 10px; text-shadow: 2px 2px 0 #000;
            transition: color 0.3s;
        }
        #timer-display.low { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.1);} 100% {transform: scale(1);} }

        .ui-panels { position: absolute; bottom: 4%; width: 92%; display: flex; justify-content: space-between; }

        .hero-icon {
            width: 80px; height: 80px; border-radius: 50%; background: #444;
            border: 3px solid #fff; background-size: cover; background-position: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            font-size: 40px; transition: 0.3s; opacity: 0.5; transform: scale(0.9);
        }
        .hero-icon.active { opacity: 1; transform: scale(1.1); border-color: #f1c40f; box-shadow: 0 0 20px #f1c40f; }
        .hero-icon.dead { filter: grayscale(1); }

        .floater {
            position: absolute; font-weight: 900; font-size: 36px;
            animation: floatUp 1s forwards; text-shadow: 2px 2px 0 #000; z-index: 100;
        }
        @keyframes floatUp { to { transform: translateY(-60px); opacity: 0; } }
        
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            pointer-events: auto; padding: 10px 20px;
            background: rgba(0,0,0,0.5); color: #fff; border: 1px solid #fff;
            text-decoration: none; border-radius: 5px; font-size: 14px;
        }
        .back-btn:hover { background: rgba(255,255,255,0.2); }

        #debug-log {
            position: absolute; bottom: 0; left: 0; 
            width: 100%; height: 100px; 
            background: rgba(0,0,0,0.5); color: #0f0; 
            font-family: monospace; font-size: 12px; 
            overflow-y: scroll; pointer-events: none;
            display: none; z-index: 9999;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="arena"></canvas>
    <div class="ui-layer">
        <a href="lobby.html" class="back-btn">‚¨Ö –í—ã–±–æ—Ä –≥–µ—Ä–æ–µ–≤</a>
        <div id="turn-display" class="turn-badge green">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
        <div id="timer-display">30</div>

        <div class="ui-panels">
            <div id="panel-green" style="display:flex; gap:10px;"></div>
            <div id="panel-red" style="display:flex; gap:10px;"></div>
        </div>
        
        <div id="debug-log"></div>
    </div>
</div>

<script>
// --- –õ–û–ì–ì–ï–† –û–®–ò–ë–û–ö ---
function log(msg) {
    console.log(msg);
    const box = document.getElementById('debug-log');
    if(box) {
        box.style.display = 'block';
        box.innerHTML += `> ${msg}<br>`;
        box.scrollTop = box.scrollHeight;
    }
}
window.onerror = function(message, source, lineno) {
    log(`ERROR: ${message} at line ${lineno}`);
};

// --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
const CFG = {
    width: 1600, height: 900,
    wallPadding: 145, cornerCut: 210,   
    radius: 40, friction: 0.985, wallBounce: 0.7, stopSpeed: 0.15,
    launchSpeed: 45, subSteps: 10,
    reviveAmount: 60, maxRevives: 1,
    turnTimeSeconds: 30
};

const HERO_STATS = {
    ranger: { hp: 300, dmg: 50, emoji: "üëÆ‚Äç‚ôÇÔ∏è", name: "–õ–µ—Å–Ω–∏–∫" },
    bear:   { hp: 450, dmg: 35, emoji: "üêª", name: "–ú–µ–¥–≤–µ–¥—å" },
    wolf:   { hp: 250, dmg: 70, emoji: "üê∫", name: "–í–æ–ª–∫" },
    poacher:{ hp: 280, dmg: 60, emoji: "üë∫", name: "–ë—Ä–∞–∫–æ–Ω—å–µ—Ä" }
};

const ASSETS = {
    bg: new Image(), ranger: new Image(), bear: new Image(), wolf: new Image(), poacher: new Image()
};
ASSETS.bg.src = 'img/bg.png';
ASSETS.ranger.src = 'img/ranger.png';
ASSETS.bear.src = 'img/bear.png';
ASSETS.wolf.src = 'img/wolf.png';
ASSETS.poacher.src = 'img/poacher.png';

const urlParams = new URLSearchParams(window.location.search);
const myUsername = urlParams.get('username') || "Player";
const p1Key = urlParams.get('p1');
const p2Key = urlParams.get('p2');

if (!p1Key || !p2Key) {
    window.location.href = 'lobby.html';
}

const SOCKET_URL = "https://forest-fight-server.onrender.com";
let socket;

try {
    socket = io(SOCKET_URL, {
        reconnection: true,
        reconnectionAttempts: 20
    });
} catch (e) {
    log("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–∫–µ—Ç–∞: " + e.message);
}

const V = {
    add: (a, b) => ({x: a.x + b.x, y: a.y + b.y}),
    sub: (a, b) => ({x: a.x - b.x, y: a.y - b.y}),
    mult: (v, n) => ({x: v.x * n, y: v.y * n}),
    mag: (a) => Math.sqrt(a.x*a.x + a.y*a.y),
    norm: (a) => { let m = Math.sqrt(a.x*a.x + a.y*a.y); return m===0 ? {x:0,y:0} : {x:a.x/m, y:a.y/m}; },
    dist: (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2)
};

class Game {
    constructor() {
        this.container = document.getElementById('game-container');
        this.canvas = document.getElementById('arena');
        this.ctx = this.canvas.getContext('2d');
        
        this.units = []; this.walls = [];
        this.state = 'AIMING'; 
        this.drag = { active: false, start: {x:0,y:0}, curr: {x:0,y:0}, unitId: null };
        this.turnTime = CFG.turnTimeSeconds; this.timerInterval = null;
        this.turnOrder = [0, 2, 1, 3]; this.turnStep = 0; this.activeUnitId = 0; 
        
        this.isOnline = true; this.roomName = null; this.myTeam = null; 
        this.canControl = false; this.isLoggedIn = false;
        this.isSimulating = false;
        this.enemyDrag = null;

        this.lastTime = performance.now();
        this.accumulator = 0;
        this.step = 1 / 60;

        this.fitScreen();
        window.addEventListener('resize', () => this.fitScreen());

        document.addEventListener("visibilitychange", () => {
            if (!document.hidden) {
                this.lastTime = performance.now(); 
            }
        });

        this.initArena();
        this.bindInput();
        this.setupNetwork(); 
        this.startBackgroundLoop();
    }

    startBackgroundLoop() {
        const workerCode = `
            let interval = null;
            self.onmessage = function(e) {
                if (e.data === 'start') {
                    if (interval) clearInterval(interval);
                    interval = setInterval(() => {
                        self.postMessage('tick');
                    }, 16);
                } else if (e.data === 'stop') {
                    clearInterval(interval);
                }
            };
        `;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        this.ticker = new Worker(workerUrl);
        this.ticker.onmessage = () => { this.loop(); };
        this.ticker.postMessage('start');
    }

    fitScreen() {
        const aspect = 16 / 9;
        let w = window.innerWidth;
        let h = window.innerHeight;
        if (w / h > aspect) w = h * aspect;
        else h = w / aspect;
        this.container.style.width = w + 'px';
        this.container.style.height = h + 'px';
        this.canvas.width = CFG.width;
        this.canvas.height = CFG.height;
    }

    getMousePos(evt) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    setupNetwork() {
        if (!socket) { log("–°–æ–∫–µ—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω!"); return; }

        const tryLogin = () => {
            if (!this.isLoggedIn && socket.connected) {
                socket.emit('login', myUsername);
            }
        };

        socket.on('connect', () => { log("Connected!"); tryLogin(); });
        if (socket.connected) { log("Already connected!"); tryLogin(); }

        const checkInt = setInterval(() => {
            if (this.isLoggedIn) clearInterval(checkInt);
            else tryLogin();
        }, 1000);

        socket.on('loginSuccess', (userData) => {
            if (this.isLoggedIn) return;
            this.isLoggedIn = true;
            log("Login OK");
            document.getElementById('debug-log').style.display = 'none';
            this.updateBanner("–ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...", "grey");
            socket.emit('findMatch', { p1: p1Key, p2: p2Key });
        });

        socket.on('gameStart', (data) => {
            log("Match Found!");
            this.roomName = data.room;
            this.myTeam = data.role;
            const enemyHeroes = data.enemyHeroes || { p1: 'poacher', p2: 'wolf' };
            this.initUnitsWithSync(this.roomName, enemyHeroes); 
            this.updateBanner(`–ë–û–ô! –í—ã: ${this.myTeam === 'green' ? '–õ–ï–°–•–û–ó' : '–ë–†–ê–ö–û–ù–¨–ï–†–´'}`, this.myTeam);
            this.canControl = true; 
            setTimeout(() => { this.startTurnLogic(); }, 2000);
        });

        socket.on('enemyShoot', (data) => {
            this.enemyDrag = null;
            this.shoot(data.unitId, data.vector, true);
        });

        socket.on('syncData', (serverUnits) => {
            this.units.forEach((u, i) => {
                if (serverUnits[i]) {
                    u.x = serverUnits[i].x;
                    u.y = serverUnits[i].y;
                    u.hp = serverUnits[i].hp;
                    u.isDead = serverUnits[i].isDead;
                    u.reviveCount = serverUnits[i].reviveCount;
                    u.vx = 0; u.vy = 0; 
                }
            });
            this.isSimulating = false;
            this.stopTimer();
            this.nextTurnIndex();
        });
        
        socket.on('enemyAim', (data) => {
            this.enemyDrag = data;
        });

        socket.on('enemyEndAim', () => {
            this.enemyDrag = null;
        });

        socket.on('opponentLeft', () => {
            alert("–°–æ–ø–µ—Ä–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª –∏–≥—Ä—É!");
            window.location.href = 'lobby.html';
        });

        socket.on('disconnect', () => {
            log("Disconnected!");
            this.isLoggedIn = false;
        });
    }

    initUnitsWithSync(seedString, enemyHeroes) {
        const sx = CFG.wallPadding + CFG.cornerCut + 30;
        const my = CFG.height / 2;
        const spr = 130;
        const spots = [ { x: sx, y: my - spr }, { x: CFG.width - sx, y: my - spr }, { x: sx, y: my + spr }, { x: CFG.width - sx, y: my + spr } ];
        const patterns = [ [0, 2, 1, 3], [0, 1, 2, 3], [3, 0, 2, 1], [1, 3, 0, 2] ];
        let seed = 0;
        for(let i=0; i<seedString.length; i++) seed += seedString.charCodeAt(i);
        const mapIndex = seed % patterns.length;
        const map = patterns[mapIndex];
        this.units = [];
        
        let greenP1, greenP2, redP1, redP2;

        if (this.myTeam === 'green') {
            greenP1 = p1Key;
            greenP2 = p2Key;
            redP1 = enemyHeroes.p1;
            redP2 = enemyHeroes.p2;
        } else {
            greenP1 = enemyHeroes.p1;
            greenP2 = enemyHeroes.p2;
            redP1 = p1Key;
            redP2 = p2Key;
        }

        this.spawnUnit('green', greenP1, spots[map[0]].x, spots[map[0]].y);
        this.spawnUnit('green', greenP2, spots[map[1]].x, spots[map[1]].y);
        this.spawnUnit('red', redP1, spots[map[2]].x, spots[map[2]].y);
        this.spawnUnit('red', redP2, spots[map[3]].x, spots[map[3]].y);
        this.updateUI();
    }

    spawnUnit(team, key, x, y) {
        const stats = HERO_STATS[key] || HERO_STATS['ranger'];
        const safeStats = stats;
        const safeKey = key;
        
        this.units.push({
            id: this.units.length, team: team, name: safeStats.name, imgKey: safeKey, emoji: safeStats.emoji,
            x: x, y: y, vx: 0, vy: 0, hp: safeStats.hp, maxHp: safeStats.hp, dmg: safeStats.dmg,
            isDead: false, reviveCount: 0,
            lastHitByTeam: null
        });
    }

    getActiveUnit() { return this.units[this.activeUnitId]; }

    startTurnLogic() {
        this.enemyDrag = null; 
        const scheduledUnitId = this.turnOrder[this.turnStep % 4];
        let scheduledUnit = this.units[scheduledUnitId];
        if (scheduledUnit.isDead) {
            const ally = this.units.find(u => u.team === scheduledUnit.team && u.id !== scheduledUnitId && !u.isDead);
            if (ally) {
                this.activeUnitId = ally.id;
                this.floatText(ally.x, ally.y, "–ó–ê –î–†–£–ì–ê!", "#f1c40f");
            } else { this.nextTurnIndex(); return; }
        } else { this.activeUnitId = scheduledUnitId; }
        const activeUnit = this.getActiveUnit();
        this.updateBanner(`–•–û–î: ${activeUnit.name}`, activeUnit.team);
        this.updateUI();
        this.state = 'AIMING';
        this.startTimer();
    }

    nextTurnIndex() {
        const gLive = this.units.some(u => u.team==='green' && !u.isDead);
        const rLive = this.units.some(u => u.team==='red' && !u.isDead);
        if(!gLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –ë—Ä–∞–∫–æ–Ω—å–µ—Ä–æ–≤', 'win'); }
        if(!rLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –õ–µ—Å—Ö–æ–∑–∞', 'win'); }
        this.turnStep++;
        this.startTurnLogic();
    }

    startTimer() {
        this.stopTimer();
        this.turnTime = CFG.turnTimeSeconds;
        this.updateTimerUI();
        const endTime = Date.now() + CFG.turnTimeSeconds * 1000;
        this.timerInterval = setInterval(() => {
            const now = Date.now();
            const left = Math.ceil((endTime - now) / 1000);
            if (left <= 0) {
                this.stopTimer();
                this.updateTimerUI(0);
                const activeUnit = this.getActiveUnit();
                if (this.isOnline && activeUnit.team === this.myTeam) {
                    this.forceRandomTurn();
                }
            } else {
                this.updateTimerUI(left);
            }
        }, 200);
    }

    stopTimer() { if (this.timerInterval) { clearInterval(this.timerInterval); this.timerInterval = null; } document.getElementById('timer-display').className = ''; }
    updateTimerUI(val) { const el = document.getElementById('timer-display'); el.innerText = val !== undefined ? val : this.turnTime; if (val <= 10) el.classList.add('low'); else el.classList.remove('low'); }

    forceRandomTurn() {
        const unit = this.getActiveUnit();
        if (unit.isDead) { this.nextTurnIndex(); return; }
        const angle = Math.random() * Math.PI * 2;
        const power = 100;
        const vec = { x: Math.cos(angle) * power, y: Math.sin(angle) * power };
        this.floatText(unit.x, unit.y, "AUTO!", '#f39c12');
        this.shoot(unit.id, vec);
    }

    bindInput() {
        let lastSendTime = 0;
        const onDown = (e) => {
            if (this.state !== 'AIMING') return;
            if (!this.canControl) return;
            const activeUnit = this.getActiveUnit();
            if (this.isOnline && activeUnit.team !== this.myTeam) return;
            const pos = this.getMousePos(e);
            const clickedUnit = this.units.find(u => !u.isDead && V.dist(pos, u) < CFG.radius * 2);
            if (clickedUnit && clickedUnit.id === activeUnit.id) {
                this.drag.active = true; this.drag.unitId = clickedUnit.id; this.drag.start = pos; this.drag.curr = pos;
            }
        };
        const onMove = (e) => { 
            if (this.drag.active) {
                this.drag.curr = this.getMousePos(e);
                const now = Date.now();
                if (now - lastSendTime > 30) {
                    const vec = V.sub(this.drag.start, this.drag.curr);
                    socket.emit('aim', { room: this.roomName, unitId: this.drag.unitId, vec: vec });
                    lastSendTime = now;
                }
            }
        };
        const onUp = (e) => {
            if (this.drag.active) {
                if (e.button === 2) { 
                    this.drag.active = false; 
                    socket.emit('endAim', { room: this.roomName });
                    return; 
                }
                this.drag.active = false;
                const vec = V.sub(this.drag.start, this.drag.curr);
                if (V.mag(vec) > 10) this.shoot(this.drag.unitId, vec);
                else socket.emit('endAim', { room: this.roomName });
            }
        };
        this.canvas.addEventListener('contextmenu', e => { e.preventDefault(); this.drag.active = false; socket.emit('endAim', { room: this.roomName }); });
        this.canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        this.canvas.addEventListener('touchstart', onDown, {passive: false});
        this.canvas.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onUp);
    }

    shoot(id, rawVec, isNetwork = false) {
        this.stopTimer();
        this.units.forEach(u => u.lastHitByTeam = null);

        if (!isNetwork && this.isOnline) {
            socket.emit('shoot', { room: this.roomName, unitId: id, vector: rawVec });
        }
        const u = this.units[id];
        const dir = V.norm(rawVec);
        u.vx = dir.x * CFG.launchSpeed;
        u.vy = dir.y * CFG.launchSpeed;
        this.state = 'MOVING';
        this.isSimulating = true; 
        this.updateBanner('–î–≤–∏–∂–µ–Ω–∏–µ...', 'grey');
    }

    loop() {
        this.ctx.clearRect(0,0, CFG.width, CFG.height);
        this.drawBackground();

        const now = performance.now();
        let dt = (now - this.lastTime) / 1000;
        this.lastTime = now;
        if (dt > 1) dt = 1; 
        this.accumulator += dt;
        let safetyCounter = 0;
        while (this.accumulator >= this.step) {
            this.update();
            this.accumulator -= this.step;
            safetyCounter++;
            if(safetyCounter > 3000) { this.accumulator = 0; break; }
        }

        if (this.state === 'AIMING') {
            if (this.drag.active) this.drawAim(this.units[this.drag.unitId], V.sub(this.drag.start, this.drag.curr), false);
            if (this.enemyDrag) {
                const u = this.units[this.enemyDrag.unitId];
                if (u && !u.isDead) this.drawAim(u, this.enemyDrag.vec, true);
            }
        }

        this.units.forEach(u => this.drawUnit(u));
    }

    update() {
        if (this.state === 'MOVING') {
            let active = false; const steps = CFG.subSteps;
            for(let s=0; s<steps; s++) {
                this.units.forEach(u => {
                    u.x += u.vx / steps; u.y += u.vy / steps;
                    for (let w of this.walls) this.solveWall(u, w);
                });
                for (let i=0; i<this.units.length; i++) {
                    for (let j=i+1; j<this.units.length; j++) { this.solveCollision(this.units[i], this.units[j]); }
                }
            }
            this.units.forEach(u => {
                u.vx *= CFG.friction; u.vy *= CFG.friction;
                if (V.mag({x:u.vx, y:u.vy}) > CFG.stopSpeed) active = true; else { u.vx = 0; u.vy = 0; }
            });
            if (!active && this.isSimulating) {
                const activeUnit = this.getActiveUnit();
                if (this.isOnline && activeUnit.team === this.myTeam) {
                    socket.emit('syncTurn', { room: this.roomName, units: this.units });
                    this.isSimulating = false;
                    this.nextTurnIndex();
                }
            }
        }
    }

    solveWall(u, w) {
        const dist = this.getDistToLine(u, w.p1, w.p2);
        if (dist < CFG.radius) {
            const dx = w.p2.x - w.p1.x; const dy = w.p2.y - w.p1.y;
            const lenW = Math.sqrt(dx*dx + dy*dy); const nx = dx/lenW; const ny = dy/lenW;
            const t = ((u.x - w.p1.x)*nx + (u.y - w.p1.y)*ny);
            let cx = w.p1.x + t*nx; let cy = w.p1.y + t*ny; 
            if(t<0){cx=w.p1.x;cy=w.p1.y;} else if(t>lenW){cx=w.p2.x;cy=w.p2.y;}
            const nxColl = (u.x - cx) / dist; 
            const nyColl = (u.y - cy) / dist;
            u.x += nxColl * (CFG.radius - dist);
            u.y += nyColl * (CFG.radius - dist);
            const dp = u.vx * nxColl + u.vy * nyColl;
            u.vx = (u.vx - 2 * dp * nxColl) * CFG.wallBounce;
            u.vy = (u.vy - 2 * dp * nyColl) * CFG.wallBounce;
            
            if (u.isDead && Math.abs(dp) > 2 && u.lastHitByTeam === u.team) { 
                this.heal(u, CFG.reviveAmount); 
            }
        }
    }

    solveCollision(u1, u2) {
        const dx = u2.x - u1.x; const dy = u2.y - u1.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < CFG.radius * 2) {
            const nx = dx / dist; const ny = dy / dist; const overlap = (CFG.radius * 2 - dist) / 2;
            u1.x -= nx * overlap; u1.y -= ny * overlap; u2.x += nx * overlap; u2.y += ny * overlap;
            const rvx = u1.vx - u2.vx; const rvy = u1.vy - u2.vy;
            const velNormal = rvx * nx + rvy * ny;
            if (velNormal < 0) return;
            const impulse = velNormal; 
            u1.vx -= impulse * nx; u1.vy -= impulse * ny;
            u2.vx += impulse * nx; u2.vy += impulse * ny;
            const impact = Math.abs(impulse);
            
            if (impact > 0.1) {
                u1.lastHitByTeam = u2.team;
                u2.lastHitByTeam = u1.team;

                if (u1.team === u2.team) {
                    if (u1.isDead) this.heal(u1, CFG.reviveAmount);
                    if (u2.isDead) this.heal(u2, CFG.reviveAmount);
                } else {
                    if (this.state === 'MOVING') {
                        if (!u1.isDead && !u2.isDead) {
                            const activeTeam = this.units[this.activeUnitId].team;
                            if (activeTeam === u1.team) this.dmg(u2, u1.dmg);
                            if (activeTeam === u2.team) this.dmg(u1, u2.dmg);
                        }
                    }
                }
            }
        }
    }

    heal(u, amt) {
        if (!u.isDead) return;
        if (u.reviveCount >= CFG.maxRevives) return;
        if(!u.lastHeal || Date.now() - u.lastHeal > 200) {
            u.hp += amt;
            this.floatText(u.x, u.y, `+${amt}`, '#3498db');
            u.lastHeal = Date.now();
        } else { u.hp += amt; }
        if (u.hp >= u.maxHp) {
            u.hp = u.maxHp;
            u.isDead = false;
            u.vx *= 0.5; u.vy *= 0.5;
            u.reviveCount++;
            this.floatText(u.x, u.y, "–û–ñ–ò–õ!", '#f1c40f');
            this.updateUI();
        }
    }

    dmg(u, amt) {
        if(u.isDead) return;
        u.hp -= amt;
        if(!u.lastDmg || Date.now() - u.lastDmg > 500) {
            this.floatText(u.x, u.y, `-${Math.round(amt)}`, '#e74c3c');
            u.lastDmg = Date.now();
        }
        if (u.hp <= 0) { 
            u.hp = 0; 
            u.isDead = true; 
            u.vx*=0.5; u.vy*=0.5; 
            this.updateUI();
        }
    }

    // --- –§–£–ù–ö–¶–ò–ò –í–ù–£–¢–†–ò –ö–õ–ê–°–°–ê ---
    initArena() {
        const pad = CFG.wallPadding; 
        const c = CFG.cornerCut; 
        const w = CFG.width; 
        const h = CFG.height;
        const points = [
            {x: pad + c, y: pad}, {x: w - pad - c, y: pad},
            {x: w - pad, y: pad + c}, {x: w - pad, y: h - pad - c},
            {x: w - pad - c, y: h - pad}, {x: pad + c, y: h - pad},
            {x: pad, y: h - pad - c}, {x: pad, y: pad + c}
        ];
        this.walls = [];
        for(let i=0; i<points.length; i++) {
            this.walls.push({ p1: points[i], p2: points[(i+1)%points.length] });
        }
    }
    
    drawBackground() {
        const ctx = this.ctx;
        if (ASSETS.bg.complete && ASSETS.bg.naturalWidth !== 0) {
            ctx.drawImage(ASSETS.bg, 0, 0, CFG.width, CFG.height);
        } else {
            ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0, CFG.width, CFG.height);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 10;
            ctx.beginPath(); ctx.moveTo(CFG.width/2, 0); ctx.lineTo(CFG.width/2, CFG.height); ctx.stroke();
            ctx.beginPath(); ctx.arc(CFG.width/2, CFG.height/2, 150, 0, Math.PI*2); ctx.stroke();
            ctx.strokeStyle = '#1e3c1b'; ctx.lineWidth = 5;
            ctx.beginPath();
            this.walls.forEach(w => { ctx.moveTo(w.p1.x, w.p1.y); ctx.lineTo(w.p2.x, w.p2.y); });
            ctx.stroke();
        }
    }
}

new Game(p1Key, p2Key);
</script>
</body>
</html>
