<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–õ–µ—Å–Ω–∞—è –ë–∏—Ç–≤–∞: –ë–æ–π</title>
    <!-- –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï SOCKET.IO -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap');

        body {
            margin: 0; padding: 0;
            background-color: #1e272e;
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Rubik', sans-serif;
            user-select: none; touch-action: none;
        }

        #game-container {
            position: relative;
            background: #2d5a27;
            width: 100vw; height: 56.25vw;
            max-height: 100vh; max-width: 177.78vh;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }

        .turn-badge {
            margin-top: 2%; padding: 1% 4%;
            background: rgba(0,0,0,0.85); border: 3px solid #fff; border-radius: 12px;
            color: #fff; font-size: 32px; text-transform: uppercase; font-weight: bold;
            text-shadow: 1px 1px 0 #000; transition: 0.3s;
        }
        .turn-badge.green { border-color: #2ecc71; color: #2ecc71; }
        .turn-badge.red { border-color: #e74c3c; color: #e74c3c; }
        .turn-badge.win { border-color: #f1c40f; color: #f1c40f; font-size: 40px;}

        #timer-display {
            font-size: 48px; font-weight: 900; color: white;
            margin-top: 10px; text-shadow: 2px 2px 0 #000;
            transition: color 0.3s;
        }
        #timer-display.low { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.1);} 100% {transform: scale(1);} }

        .ui-panels { position: absolute; bottom: 4%; width: 92%; display: flex; justify-content: space-between; }

        .hero-icon {
            width: 80px; height: 80px; border-radius: 50%; background: #444;
            border: 3px solid #fff; background-size: cover; background-position: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            font-size: 40px; transition: 0.3s; opacity: 0.5; transform: scale(0.9);
        }
        .hero-icon.active { opacity: 1; transform: scale(1.1); border-color: #f1c40f; box-shadow: 0 0 20px #f1c40f; }
        .hero-icon.dead { filter: grayscale(1); }

        .floater {
            position: absolute; font-weight: 900; font-size: 36px;
            animation: floatUp 1s forwards; text-shadow: 2px 2px 0 #000; z-index: 100;
        }
        @keyframes floatUp { to { transform: translateY(-60px); opacity: 0; } }
        
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            pointer-events: auto; padding: 10px 20px;
            background: rgba(0,0,0,0.5); color: #fff; border: 1px solid #fff;
            text-decoration: none; border-radius: 5px; font-size: 14px;
        }
        .back-btn:hover { background: rgba(255,255,255,0.2); }

        /* –û–¢–õ–ê–î–û–ß–ù–ê–Ø –ö–û–ù–°–û–õ–¨ –ù–ê –≠–ö–†–ê–ù–ï */
        #debug-log {
            position: absolute; bottom: 0; left: 0; 
            width: 100%; height: 100px; 
            background: rgba(0,0,0,0.5); color: #0f0; 
            font-family: monospace; font-size: 12px; 
            overflow-y: scroll; pointer-events: none;
            display: none; 
            z-index: 9999;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="arena"></canvas>
    <div class="ui-layer">
        <a href="lobby.html" class="back-btn">‚¨Ö –í—ã–±–æ—Ä –≥–µ—Ä–æ–µ–≤</a>
        <div id="turn-display" class="turn-badge green">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
        <div id="timer-display">30</div>

        <div class="ui-panels">
            <div id="panel-green" style="display:flex; gap:10px;"></div>
            <div id="panel-red" style="display:flex; gap:10px;"></div>
        </div>
        
        <div id="debug-log"></div>
    </div>
</div>

<script>
// --- –õ–û–ì–ì–ï–† –û–®–ò–ë–û–ö ---
function log(msg) {
    console.log(msg);
    const box = document.getElementById('debug-log');
    if(box) {
        box.style.display = 'block';
        box.innerHTML += `> ${msg}<br>`;
        box.scrollTop = box.scrollHeight;
    }
}
window.onerror = function(message, source, lineno) {
    log(`ERROR: ${message} at line ${lineno}`);
};

// --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
const CFG = {
    width: 1600, height: 900,
    wallPadding: 145, cornerCut: 210,   
    radius: 40, friction: 0.985, wallBounce: 0.7, stopSpeed: 0.15,
    launchSpeed: 45, subSteps: 10,
    reviveAmount: 60, maxRevives: 1,
    turnTimeSeconds: 30
};

const HERO_STATS = {
    ranger: { hp: 300, dmg: 50, emoji: "üëÆ‚Äç‚ôÇÔ∏è", name: "–õ–µ—Å–Ω–∏–∫" },
    bear:   { hp: 450, dmg: 35, emoji: "üêª", name: "–ú–µ–¥–≤–µ–¥—å" },
    wolf:   { hp: 250, dmg: 70, emoji: "üê∫", name: "–í–æ–ª–∫" },
    poacher:{ hp: 280, dmg: 60, emoji: "üë∫", name: "–ë—Ä–∞–∫–æ–Ω—å–µ—Ä" }
};

const ASSETS = {
    bg: new Image(),
    ranger: new Image(),
    bear: new Image(),
    wolf: new Image(),
    poacher: new Image()
};

ASSETS.bg.src      = 'img/bg.png';
ASSETS.ranger.src  = 'img/ranger.png';
ASSETS.bear.src    = 'img/bear.png';
ASSETS.wolf.src    = 'img/wolf.png';
ASSETS.poacher.src = 'img/poacher.png';

// --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–õ–ò–ï–ù–¢–ê ---
const urlParams = new URLSearchParams(window.location.search);
const myUsername = urlParams.get('username') || "Player";
const p1Param = urlParams.get('p1');
const p2Param = urlParams.get('p2');

if (!p1Param || !p2Param) {
    window.location.href = 'lobby.html';
}

const SOCKET_URL = "https://forest-fight-server.onrender.com";
let socket;

try {
    socket = io(SOCKET_URL, {
        reconnection: true,
        reconnectionAttempts: 20
    });
} catch (e) {
    log("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–∫–µ—Ç–∞: " + e.message);
}

const V = {
    add: (a, b) => ({x: a.x + b.x, y: a.y + b.y}),
    sub: (a, b) => ({x: a.x - b.x, y: a.y - b.y}),
    mult: (v, n) => ({x: v.x * n, y: v.y * n}),
    mag: (a) => Math.sqrt(a.x*a.x + a.y*a.y),
    norm: (a) => { let m = Math.sqrt(a.x*a.x + a.y*a.y); return m===0 ? {x:0,y:0} : {x:a.x/m, y:a.y/m}; },
    dist: (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2)
};

class Game {
    constructor(p1Key, p2Key) {
        this.container = document.getElementById('game-container');
        this.canvas = document.getElementById('arena');
        this.ctx = this.canvas.getContext('2d');
        
        this.units = [];
        this.walls = [];
        this.state = 'AIMING'; 
        this.drag = { active: false, start: {x:0,y:0}, curr: {x:0,y:0}, unitId: null };
        
        this.turnTime = CFG.turnTimeSeconds;
        this.timerInterval = null;
        this.turnOrder = [0, 2, 1, 3]; 
        this.turnStep = 0;
        this.activeUnitId = 0; 

        this.p1Key = p1Key;
        this.p2Key = p2Key;

        this.isOnline = true;
        this.roomName = null;
        this.myTeam = null; 
        this.canControl = false; 
        this.isLoggedIn = false;

        // !!! –í–û–¢ –ü–†–û–ü–£–©–ï–ù–ù–´–ï –ú–ï–¢–û–î–´ !!!
        this.fitScreen();
        window.addEventListener('resize', () => this.fitScreen());

        this.initArena();
        this.bindInput();
        
        this.setupNetwork(); 
        
        this.loop();
    }

    // --- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î ---
    fitScreen() {
        const aspect = 16 / 9;
        let w = window.innerWidth;
        let h = window.innerHeight;
        if (w / h > aspect) w = h * aspect;
        else h = w / aspect;
        this.container.style.width = w + 'px';
        this.container.style.height = h + 'px';
        this.canvas.width = CFG.width;
        this.canvas.height = CFG.height;
    }

    // --- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î ---
    getMousePos(evt) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    setupNetwork() {
        if (!socket) {
            log("–°–æ–∫–µ—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω!");
            return;
        }

        const tryLogin = () => {
            if (!this.isLoggedIn && socket.connected) {
                socket.emit('login', myUsername);
            }
        };

        socket.on('connect', () => {
            log("Connected to server!");
            tryLogin();
        });

        if (socket.connected) {
            log("Already connected!");
            tryLogin();
        }

        const checkInt = setInterval(() => {
            if (this.isLoggedIn) clearInterval(checkInt);
            else tryLogin();
        }, 1000);

        socket.on('loginSuccess', (userData) => {
            if (this.isLoggedIn) return;
            this.isLoggedIn = true;
            log("Login OK: " + userData.username);
            
            document.getElementById('debug-log').style.display = 'none';
            
            this.updateBanner("–ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...", "grey");
            socket.emit('findMatch');
        });

        socket.on('gameStart', (data) => {
            log("Match Found! Room: " + data.room);
            this.roomName = data.room;
            this.myTeam = data.role;
            
            this.initUnitsWithSync(this.roomName); 

            this.updateBanner(`–ë–û–ô! –í—ã: ${this.myTeam === 'green' ? '–õ–ï–°–•–û–ó' : '–ë–†–ê–ö–û–ù–¨–ï–†–´'}`, this.myTeam);
            this.canControl = true; 
            
            setTimeout(() => {
                this.startTurnLogic();
            }, 2000);
        });

        socket.on('enemyShoot', (data) => {
            this.shoot(data.unitId, data.vector, true);
        });
        
        socket.on('disconnect', () => {
            log("Disconnected!");
            this.isLoggedIn = false;
        });
    }

    initUnitsWithSync(seedString) {
        const sx = CFG.wallPadding + CFG.cornerCut + 30;
        const my = CFG.height / 2;
        const spr = 130;

        const spots = [
            { x: sx, y: my - spr },             
            { x: CFG.width - sx, y: my - spr }, 
            { x: sx, y: my + spr },             
            { x: CFG.width - sx, y: my + spr }  
        ];

        const patterns = [
            [0, 2, 1, 3], [0, 1, 2, 3], [3, 0, 2, 1], [1, 3, 0, 2]
        ];

        let seed = 0;
        for(let i=0; i<seedString.length; i++) seed += seedString.charCodeAt(i);
        const mapIndex = seed % patterns.length;
        const map = patterns[mapIndex];

        this.units = [];
        this.spawnUnit('green', this.p1Key, spots[map[0]].x, spots[map[0]].y);
        this.spawnUnit('green', this.p2Key, spots[map[1]].x, spots[map[1]].y);
        this.spawnUnit('red', 'poacher', spots[map[2]].x, spots[map[2]].y);
        this.spawnUnit('red', 'wolf',    spots[map[3]].x, spots[map[3]].y);
        this.updateUI();
    }

    spawnUnit(team, key, x, y) {
        const stats = HERO_STATS[key];
        const safeStats = stats || HERO_STATS['ranger'];
        const safeKey = stats ? key : 'ranger';
        
        this.units.push({
            id: this.units.length,
            team: team,
            name: safeStats.name,
            imgKey: safeKey,
            emoji: safeStats.emoji,
            x: x, y: y, vx: 0, vy: 0,
            hp: safeStats.hp, maxHp: safeStats.hp, dmg: safeStats.dmg,
            isDead: false,
            reviveCount: 0
        });
    }

    getActiveUnit() {
        return this.units[this.activeUnitId];
    }

    startTurnLogic() {
        const scheduledUnitId = this.turnOrder[this.turnStep % 4];
        let scheduledUnit = this.units[scheduledUnitId];

        if (scheduledUnit.isDead) {
            const ally = this.units.find(u => u.team === scheduledUnit.team && u.id !== scheduledUnitId && !u.isDead);
            if (ally) {
                this.activeUnitId = ally.id;
                this.floatText(ally.x, ally.y, "–ó–ê –î–†–£–ì–ê!", "#f1c40f");
            } else {
                this.nextTurnIndex();
                return;
            }
        } else {
            this.activeUnitId = scheduledUnitId;
        }

        const activeUnit = this.getActiveUnit();
        this.updateBanner(`–•–û–î: ${activeUnit.name}`, activeUnit.team);
        this.updateUI();
        
        this.state = 'AIMING';
        this.startTimer();
    }

    nextTurnIndex() {
        const gLive = this.units.some(u => u.team==='green' && !u.isDead);
        const rLive = this.units.some(u => u.team==='red' && !u.isDead);
        
        if(!gLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –ë—Ä–∞–∫–æ–Ω—å–µ—Ä–æ–≤', 'win'); }
        if(!rLive) { this.stopTimer(); return this.updateBanner('–ü–æ–±–µ–¥–∞ –õ–µ—Å—Ö–æ–∑–∞', 'win'); }

        this.turnStep++;
        this.startTurnLogic();
    }

    startTimer() {
        this.stopTimer();
        this.turnTime = CFG.turnTimeSeconds;
        this.updateTimerUI();

        this.timerInterval = setInterval(() => {
            this.turnTime--;
            this.updateTimerUI();

            if (this.turnTime <= 0) {
                this.stopTimer();
                const activeUnit = this.getActiveUnit();
                if (this.isOnline && activeUnit.team === this.myTeam) {
                    this.forceRandomTurn();
                }
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
        document.getElementById('timer-display').className = '';
    }

    updateTimerUI() {
        const el = document.getElementById('timer-display');
        el.innerText = this.turnTime;
        if (this.turnTime <= 10) el.classList.add('low');
        else el.classList.remove('low');
    }

    forceRandomTurn() {
        const unit = this.getActiveUnit();
        if (unit.isDead) { this.nextTurnIndex(); return; }

        const angle = Math.random() * Math.PI * 2;
        const power = 100;
        const vec = { x: Math.cos(angle) * power, y: Math.sin(angle) * power };

        this.floatText(unit.x, unit.y, "AUTO!", '#f39c12');
        this.shoot(unit.id, vec);
    }

    bindInput() {
        const onDown = (e) => {
            if (this.state !== 'AIMING') return;
            if (!this.canControl) return;

            const activeUnit = this.getActiveUnit();
            if (this.isOnline && activeUnit.team !== this.myTeam) return;

            const pos = this.getMousePos(e);
            const clickedUnit = this.units.find(u => !u.isDead && V.dist(pos, u) < CFG.radius * 2);
            
            if (clickedUnit && clickedUnit.id === activeUnit.id) {
                this.drag.active = true;
                this.drag.unitId = clickedUnit.id;
                this.drag.start = pos;
                this.drag.curr = pos;
            }
        };
        const onMove = (e) => {
            if (this.drag.active) this.drag.curr = this.getMousePos(e);
        };
        const onUp = (e) => {
            if (this.drag.active) {
                if (e.button === 2) { 
                    this.drag.active = false;
                    return;
                }
                this.drag.active = false;
                const vec = V.sub(this.drag.start, this.drag.curr);
                if (V.mag(vec) > 10) this.shoot(this.drag.unitId, vec);
            }
        };

        this.canvas.addEventListener('contextmenu', e => { e.preventDefault(); this.drag.active = false; });
        this.canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        this.canvas.addEventListener('touchstart', onDown, {passive: false});
        this.canvas.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onUp);
    }

    shoot(id, rawVec, isNetwork = false) {
        this.stopTimer();
        if (!isNetwork && this.isOnline) {
            socket.emit('shoot', { room: this.roomName, unitId: id, vector: rawVec });
        }
        const u = this.units[id];
        const dir = V.norm(rawVec);
        u.vx = dir.x * CFG.launchSpeed;
        u.vy = dir.y * CFG.launchSpeed;
        this.state = 'MOVING';
        this.updateBanner('–î–≤–∏–∂–µ–Ω–∏–µ...', 'grey');
    }

    update() {
        if (this.state === 'MOVING') {
            let active = false;
            const steps = CFG.subSteps;
            for(let s=0; s<steps; s++) {
                this.units.forEach(u => {
                    u.x += u.vx / steps; 
                    u.y += u.vy / steps;
                    for (let w of this.walls) this.solveWall(u, w);
                });
                for (let i=0; i<this.units.length; i++) {
                    for (let j=i+1; j<this.units.length; j++) {
                        this.solveCollision(this.units[i], this.units[j]);
                    }
                }
            }
            this.units.forEach(u => {
                u.vx *= CFG.friction;
                u.vy *= CFG.friction;
                if (V.mag({x:u.vx, y:u.vy}) > CFG.stopSpeed) active = true;
                else { u.vx = 0; u.vy = 0; }
            });
            if (!active) this.nextTurnIndex();
        }
    }

    solveWall(u, w) {
        const dist = this.getDistToLine(u, w.p1, w.p2);
        if (dist < CFG.radius) {
            const dx = w.p2.x - w.p1.x; const dy = w.p2.y - w.p1.y;
            const lenW = Math.sqrt(dx*dx + dy*dy);
            const nx = dx/lenW; const ny = dy/lenW;
            const t = ((u.x - w.p1.x)*nx + (u.y - w.p1.y)*ny);
            let cx = w.p1.x + t*nx; let cy = w.p1.y + t*ny; 
            if(t<0){cx=w.p1.x;cy=w.p1.y;} else if(t>lenW){cx=w.p2.x;cy=w.p2.y;}
            const nxColl = (u.x - cx) / dist; 
            const nyColl = (u.y - cy) / dist;
            u.x += nxColl * (CFG.radius - dist);
            u.y += nyColl * (CFG.radius - dist);
            const dp = u.vx * nxColl + u.vy * nyColl;
            u.vx = (u.vx - 2 * dp * nxColl) * CFG.wallBounce;
            u.vy = (u.vy - 2 * dp * nyColl) * CFG.wallBounce;
            if (u.isDead && Math.abs(dp) > 2) { this.heal(u, CFG.reviveAmount); }
        }
    }

    solveCollision(u1, u2) {
        const dx = u2.x - u1.x; const dy = u2.y - u1.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < CFG.radius * 2) {
            const nx = dx / dist; const ny = dy / dist;
            const overlap = (CFG.radius * 2 - dist) / 2;
            u1.x -= nx * overlap; u1.y -= ny * overlap;
            u2.x += nx * overlap; u2.y += ny * overlap;
            const rvx = u1.vx - u2.vx; const rvy = u1.vy - u2.vy;
            const velNormal = rvx * nx + rvy * ny;
            if (velNormal < 0) return;
            const impulse = velNormal; 
            u1.vx -= impulse * nx; u1.vy -= impulse * ny;
            u2.vx += impulse * nx; u2.vy += impulse * ny;
            const impact = Math.abs(impulse);
            if (impact > 0.1) {
                if (u1.team === u2.team) {
                    if (u1.isDead) this.heal(u1, CFG.reviveAmount);
                    if (u2.isDead) this.heal(u2, CFG.reviveAmount);
                } else {
                    if (this.state === 'MOVING') {
                        if (!u1.isDead && !u2.isDead) {
                            const activeTeam = this.units[this.activeUnitId].team;
                            if (activeTeam === u1.team) this.dmg(u2, u1.dmg);
                            if (activeTeam === u2.team) this.dmg(u1, u2.dmg);
                        }
                    }
                }
            }
        }
    }

    heal(u, amt) {
        if (!u.isDead) return;
        if (u.reviveCount >= CFG.maxRevives) return;
        if(!u.lastHeal || Date.now() - u.lastHeal > 200) {
            u.hp += amt;
            this.floatText(u.x, u.y, `+${amt}`, '#3498db');
            u.lastHeal = Date.now();
        } else { u.hp += amt; }
        if (u.hp >= u.maxHp) {
            u.hp = u.maxHp;
            u.isDead = false;
            u.vx *= 0.5; u.vy *= 0.5;
            u.reviveCount++;
            this.floatText(u.x, u.y, "–û–ñ–ò–õ!", '#f1c40f');
            this.updateUI();
        }
    }

    dmg(u, amt) {
        if(u.isDead) return;
        u.hp -= amt;
        if(!u.lastDmg || Date.now() - u.lastDmg > 500) {
            this.floatText(u.x, u.y, `-${Math.round(amt)}`, '#e74c3c');
            u.lastDmg = Date.now();
        }
        if (u.hp <= 0) { 
            u.hp = 0; 
            u.isDead = true; 
            u.vx*=0.5; u.vy*=0.5; 
            this.updateUI();
        }
    }

    drawBackground() {
        const ctx = this.ctx;
        if (ASSETS.bg.complete && ASSETS.bg.naturalWidth !== 0) {
            ctx.drawImage(ASSETS.bg, 0, 0, CFG.width, CFG.height);
        } else {
            ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0, CFG.width, CFG.height);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 10;
            ctx.beginPath(); ctx.moveTo(CFG.width/2, 0); ctx.lineTo(CFG.width/2, CFG.height); ctx.stroke();
            ctx.beginPath(); ctx.arc(CFG.width/2, CFG.height/2, 150, 0, Math.PI*2); ctx.stroke();
            ctx.strokeStyle = '#1e3c1b'; ctx.lineWidth = 5;
            ctx.beginPath();
            this.walls.forEach(w => { ctx.moveTo(w.p1.x, w.p1.y); ctx.lineTo(w.p2.x, w.p2.y); });
            ctx.stroke();
        }
    }

    drawUnit(u) {
        const ctx = this.ctx;
        const r = CFG.radius;
        ctx.save(); ctx.translate(u.x, u.y);
        if(u.isDead) ctx.filter = 'grayscale(1) brightness(0.5)';
        ctx.beginPath(); ctx.arc(5,5,r,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fill();
        if (this.state==='AIMING' && u.id === this.activeUnitId && !u.isDead) {
            ctx.beginPath(); ctx.arc(0,0,r+5,0,Math.PI*2);
            ctx.strokeStyle='#f1c40f'; ctx.lineWidth=5; ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.save(); ctx.clip();
        const img = ASSETS[u.imgKey];
        if (img && img.complete && img.naturalWidth !== 0) {
            const sSize = Math.min(img.width, img.height);
            const sx = (img.width - sSize) / 2;
            const sy = (img.height - sSize) / 2;
            ctx.drawImage(img, sx, sy, sSize, sSize, -r, -r, r*2, r*2);
        } else {
            ctx.fillStyle = u.team==='green'?'#2ecc71':'#e74c3c'; ctx.fill();
            ctx.fillStyle='#fff'; ctx.font='45px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(u.emoji, 0, 5); 
        }
        ctx.restore();
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.lineWidth=4; 
        ctx.strokeStyle = u.team==='green'?'#2ecc71':'#e74c3c'; ctx.stroke();
        const pct = u.hp/u.maxHp;
        ctx.fillStyle='#333'; ctx.fillRect(-30, r+10, 60, 10);
        if (u.isDead) {
            if (u.reviveCount >= CFG.maxRevives) {
                ctx.fillStyle = '#555'; ctx.fillRect(-28, r+12, 56, 6); 
                ctx.font='20px Arial'; ctx.textAlign='center'; ctx.fillStyle='#ff0000'; ctx.fillText('‚ùå', 0, -r/2);
            } else {
                ctx.fillStyle = '#3498db'; ctx.fillRect(-28, r+12, 56*pct, 6);
                ctx.font='20px Arial'; ctx.textAlign='center'; ctx.fillStyle='#fff'; ctx.fillText('üíÄ', 0, -r/2);
            }
        } else {
            ctx.fillStyle = u.team==='green'?'#2ecc71':'#e74c3c'; ctx.fillRect(-28, r+12, 56*pct, 6);
        }
        ctx.restore();
    }
    
    getDistToLine(u, p1, p2) {
        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
        const lenW = Math.sqrt(dx*dx + dy*dy);
        const nx = dx/lenW; const ny = dy/lenW;
        const t = ((u.x - p1.x)*nx + (u.y - p1.y)*ny);
        let cx, cy;
        if(t < 0) { cx = p1.x; cy = p1.y; } else if(t > lenW) { cx = p2.x; cy = p2.y; } else { cx = p1.x + t*nx; cy = p1.y + t*ny; }
        return Math.sqrt((u.x-cx)**2 + (u.y-cy)**2);
    }

    predictHit(u, vec) {
        const maxDist = 2500; const dir = V.norm(vec); let cx = u.x; let cy = u.y; const step = 10;
        for(let d=0; d<maxDist; d+=step) {
            cx += dir.x * step; cy += dir.y * step;
            for(let w of this.walls) {
                const dist = this.getDistToLine({x:cx,y:cy}, w.p1, w.p2);
                if(dist < CFG.radius) {
                    const dx = w.p2.x - w.p1.x; const dy = w.p2.y - w.p1.y;
                    const lenW = Math.sqrt(dx*dx + dy*dy); const nx = dx/lenW; const ny = dy/lenW; 
                    const wnx = -ny; const wny = nx; const dot = dir.x*wnx + dir.y*wny;
                    return { type: 'wall', x: cx, y: cy, rx: dir.x - 2*dot*wnx, ry: dir.y - 2*dot*wny };
                }
            }
            for(let other of this.units) {
                if(other.id === u.id || other.isDead) continue;
                const dist = Math.sqrt((cx - other.x)**2 + (cy - other.y)**2);
                if(dist < CFG.radius * 2) {
                    let nx = cx - other.x; let ny = cy - other.y;
                    const ln = Math.sqrt(nx*nx + ny*ny); nx/=ln; ny/=ln; const dot = dir.x*nx + dir.y*ny;
                    return { type: 'unit', x: cx, y: cy, rx: dir.x - 2*dot*nx, ry: dir.y - 2*dot*ny, enemy: other.team !== u.team ? other : null };
                }
            }
        }
        return { type: 'none', x: cx, y: cy };
    }

    drawAim() {
        const u = this.units[this.drag.unitId];
        const vec = V.sub(this.drag.start, this.drag.curr);
        const hit = this.predictHit(u, vec);
        const startX = u.x + V.norm(vec).x * CFG.radius; const startY = u.y + V.norm(vec).y * CFG.radius;
        this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(hit.x, hit.y);
        this.ctx.lineWidth = 6; this.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        this.ctx.setLineDash([15,10]); this.ctx.stroke(); this.ctx.setLineDash([]);
        if(hit.type !== 'none' && hit.rx) {
            this.ctx.beginPath(); this.ctx.arc(hit.x, hit.y, 6, 0, Math.PI*2); this.ctx.fillStyle = '#fff'; this.ctx.fill();
            const bounceLen = 50; this.ctx.beginPath(); this.ctx.moveTo(hit.x, hit.y);
            this.ctx.lineTo(hit.x + hit.rx * bounceLen, hit.y + hit.ry * bounceLen);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; this.ctx.stroke();
        }
        if(hit.enemy) {
            const en = hit.enemy; this.ctx.save(); this.ctx.translate(en.x, en.y - 65);
            this.ctx.fillStyle = 'rgba(0,0,0,0.8)'; this.ctx.fillRect(-40, -30, 80, 40);
            this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.strokeRect(-40, -30, 80, 40);
            this.ctx.fillStyle = '#ff5555'; this.ctx.font = 'bold 24px Arial';
            this.ctx.textAlign = 'center'; this.ctx.fillText(`-${u.dmg}`, 0, -2);
            this.ctx.restore();
        }
    }

    updateBanner(txt, type) {
        const el = document.getElementById('turn-display');
        el.innerText = txt;
        el.className = `turn-badge ${type}`;
    }

    updateUI() {
        const render = (id, list) => {
            const div = document.getElementById(id);
            div.innerHTML='';
            list.forEach(u => {
                const d = document.createElement('div');
                d.className = `hero-icon ${u.isDead?'dead':''}`;
                if (u.id === this.activeUnitId) d.classList.add('active');
                const img = ASSETS[u.imgKey];
                if(img && img.complete && img.naturalWidth !== 0) {
                     d.style.backgroundImage = `url(${img.src})`; d.innerText = '';
                } else {
                     d.innerText = u.emoji; d.style.color = '#fff'; d.style.display = 'flex';
                }
                div.appendChild(d);
            });
        };
        render('panel-green', this.units.filter(u=>u.team==='green'));
        render('panel-red', this.units.filter(u=>u.team==='red'));
    }

    floatText(x, y, txt, col) {
        const wrapper = document.getElementById('game-container');
        const pctX = (x / CFG.width) * 100; const pctY = (y / CFG.height) * 100;
        const el = document.createElement('div'); el.className='floater'; el.style.left = pctX + '%'; el.style.top = pctY + '%';
        el.style.color = col; el.innerText = txt;
        wrapper.appendChild(el);
        setTimeout(()=>el.remove(), 1200);
    }

    loop() {
        this.update();
        this.ctx.clearRect(0,0, CFG.width, CFG.height);
        this.drawBackground();
        if (this.state === 'AIMING' && this.drag.active) this.drawAim();
        this.units.forEach(u => this.drawUnit(u));
        requestAnimationFrame(() => this.loop());
    }
}

// –ó–ê–ü–£–°–ö
if(p1Param && p2Param) {
    new Game(p1Param, p2Param);
} else {
    window.location.href = 'lobby.html';
}
</script>
</body>
</html>
